
    <html>
      <head>
        <title>dbm</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="UTF-8">
      </head>
      <body>
        <div id='content'>
    <h2 id="-dbm"># dbm</h2>
<p>基于spring jdbc实现的轻量级orm   </p>
<p>项目github地址：<a href="https://github.com/wayshall/dbm"> dbm </a></p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#特色">特色</a></li>
<li><a href="#示例项目">示例项目</a></li>
<li><a href="#要求">要求</a></li>
<li><a href="#maven">maven配置</a></li>
<li><a href="#一行代码启用">一行代码启用</a></li>
<li><a href="#实体映射">实体映射</a></li>
<li><a href="#id策略">id策略</a></li>
<li><a href="#复合主键映射">复合主键映射</a></li>
<li><a href="#其它特有的映射">其它特有的映射</a></li>
<li><a href="#BaseEntityManager接口和QueryDSL">BaseEntityManager接口和QueryDSL</a></li>
<li><a href="#crudentitymanager接口">CrudEntityManager接口</a></li>
<li><a href="#DbmRepository动态sql查询接口">DbmRepository动态sql查询接口</a></li>
<li><a href="#动态sql查询的语法和指令">动态sql查询的语法和指令</a></li>
<li><a href="#dbmrepository接口的多数据源支持">DbmRepository接口的多数据源支持</a></li>
<li><a href="#dbmrepository接口对其它orm框架的兼容">DbmRepository接口对其它orm框架的兼容</a></li>
<li><a href="#查询映射">查询映射</a></li>
<li><a href="#复杂的嵌套查询映射">复杂的嵌套查询映射</a></li>
<li><a href="#自定义实现dbmrepository接口">自定义实现DbmRepository接口</a></li>
<li><a href="#枚举处理">枚举处理</a></li>
<li><a href="#json映射">json映射</a></li>
<li><a href="#敏感字段映射">敏感字段映射</a></li>
<li><a href="#字段绑定">字段绑定</a></li>
<li><a href="#其它映射特性">其它映射特性</a></li>
<li><a href="#批量插入">批量插入</a></li>
<li><a href="#充血模型支持">充血模型支持</a></li>
<li><a href="#参数配置">参数配置</a></li>
<li><a href="#代码生成器">代码生成器</a></li>
</ul>
<h2 id="特色">特色</h2>
<ul>
<li><p>基本的实体增删改查（单表）不需要生成样板代码和sql文件。</p></li>
<li><p>返回结果不需要手动映射，会根据字段名称自动映射。</p></li>
<li><p>支持sql语句和接口绑定风格的DAO，但sql不是写在丑陋的xml里，而是直接写在sql文件里，这样用eclipse或者相关支持sql的编辑器打开时，就可以语法高亮，更容易阅读。</p></li>
<li><p>支持sql脚本修改后重新加载</p></li>
<li><p>内置支持分页查询。</p></li>
<li><p>接口支持批量插入</p></li>
<li><p>使用Java8新增的编译特性，不需要使用类似@Param 的注解标注参数,当然你可以显式使用注解标注参数。</p></li>
<li><p>Repository接口（用注解@DbmRepository标注了的接口）支持默认方法</p></li>
<li><p>支持多数据源绑定，可以为每个Repository接口指定具体的数据源</p></li>
<li><p>支持不同的数据库绑定，Repository接口会根据当前绑定的数据源自动绑定加载对应数据库后缀的sql文件</p></li>
<li><p>提供充血模型支持</p></li>
<li><p>支持json映射，直接把数据库的json或者varchar类型（存储内容为json数据）的列映射为Java对象</p></li>
<li><p>支持敏感字段映射</p></li>
</ul>
<h2 id="示例项目">示例项目</h2>
<p>单独使用dbm的示例项目<br />
<a href="https://github.com/wayshall/boot-dbm-sample">boot-dbm-sample</a></p>
<h2 id="要求">要求</h2>
<p>JDK 1.8+<br />
spring 4.0+</p>
<h2 id="maven">maven</h2>
<p>当前snapshot版本：4.7.4-SNAPSHOT</p>
<p>若使用snapshot版本，请添加snapshotRepository仓储：</p>
<pre><code class="xml language-xml">&lt;repository&gt;
     &lt;id&gt;oss&lt;/id&gt;
     &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;
    &lt;snapshots&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
    &lt;/snapshots&gt;
&lt;/repository&gt;   
</code></pre>
<p>添加依赖：   </p>
<pre><code class="xml language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.onetwo4j&lt;/groupId&gt;
    &lt;artifactId&gt;onetwo-dbm&lt;/artifactId&gt;
    &lt;version&gt;4.7.4-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>spring的依赖请自行添加。</p>
<h2 id="一行代码启用">一行代码启用</h2>
<p>在已配置好数据源的前提下，只需要在spring配置类（即有@Configuration注解的类）上加上注解@EnableDbm即可。<br />
```java     </p>
<pre><code>@EnableDbm
@Configuration
public class SpringContextConfig {
}   
</code></pre>
<pre><code>## 实体映射
</code></pre>
<p>java   <br />
<a href="https://github.com/Entity">@Entity</a>   <br />
<a href="https://github.com/Table">@Table</a>(name="TEST<em>USER</em>AUTOID")   <br />
public class UserAutoidEntity {</p>
<pre><code>@Id
@GeneratedValue(strategy=GenerationType.IDENTITY) 
@Column(name="ID")
protected Long id;
@Length(min=1, max=50)
protected String userName;
@Length(min=0, max=50)
@Email
protected String email;
protected String mobile;
protected UserStatus status;

//省略getter和setter
</code></pre>
<p>}   </p>
<pre><code>### 注意这里用到了一些jpa的注解，含义和jpa一致：
- @Entity，表示这是一个映射到数据库表的实体
- @Table，表示这个实体映射的表
- @Id，表示这是一个主键字段
- @GeneratedValue(strategy=GenerationType.IDENTITY)，表示这个主键的值用数据库自增的方式生成，dbm目前只支持IDENTITY和SEQUENCE两种方式      
- @Column，表示映射到表的字段，一般用在java的字段名和表的字段名不对应的时候   

java的字段名使用驼峰的命名风格，而数据库使用下划线的风格，dbm会自动做转换   
注意dbm并没有实现jpa规范，只是借用了几个jpa的注解，纯属只是为了方便。。。
后来为了证明我也不是真的很懒，也写了和@Entity、@Table、@Column对应的注解，分别是：@DbmEntity（@Entity和@Table合一），@DbmColumn。。。


- 注意：为了保持简单和轻量级，dbm的实体映射只支持单表，不支持多表级联映射。复杂的查询和映射请使用[DbmRepository接口](#dbmrepository接口)

## id策略
dbm支持jpa的GenerationType的id策略，此外还提供了通过@DbmIdGenerator自定义的策略：
- GenerationType.IDENTITY   
  使用数据库本身的自增策略
- GenerationType.SEQUENCE   
  使用数据库的序列策略（只支持oracle）
- GenerationType.TABLE   
  使用自定义的数据库表管理序列
- GenerationType.AUTO   
  目前的实现是：如果是mysql，则等同于GenerationType.IDENTITY，如果是oracle，则等同于GenerationType.SEQUENCE   
- DbmIdGenerator   
  dbm提供id生成注解，可通过配置 generatorClass 属性，配置自定义的id实现类，实现类必须实现CustomIdGenerator接口。dbm首先会通过尝试在spring context查找generatorClass类型的bean，如果找不到则通过反射创建实例。


### 详细使用
#### GenerationType.IDENTITY
</code></pre>
<p>Java<br />
<a href="https://github.com/Entity">@Entity</a><br />
<a href="https://github.com/Table">@Table</a>(name="t_user")<br />
public class UserEntity implements Serializable {</p>
<pre><code>@Id
@GeneratedValue(strategy=GenerationType.IDENTITY) 
protected Long id;
</code></pre>
<p>}</p>
<pre><code>#### GenerationType.TABLE
</code></pre>
<p>Java<br />
<a href="https://github.com/Entity">@Entity</a><br />
<a href="https://github.com/Table">@Table</a>(name="t_user")<br />
public class UserEntity implements Serializable {</p>
<pre><code>@Id
@GeneratedValue(strategy = GenerationType.TABLE, generator="tableIdGenerator")  
@TableGenerator(name = "tableIdGenerator",  
    table="gen_ids",  
    pkColumnName="gen_name",  
    valueColumnName="gen_value",  
    pkColumnValue="seq_test_user",  
    allocationSize=50
)
protected Long id;
</code></pre>
<p>}</p>
<pre><code>#### GenerationType.SEQUENCE
</code></pre>
<p>Java<br />
<a href="https://github.com/Entity">@Entity</a><br />
<a href="https://github.com/Table">@Table</a>(name="t_user")<br />
public class UserEntity implements Serializable {</p>
<pre><code>@Id
@GeneratedValue(strategy=GenerationType.SEQUENCE, generator="seqGenerator") 
@SequenceGenerator(name="seqGenerator", sequenceName="SEQ_TEST_USER")
protected Long id;
</code></pre>
<p>}</p>
<pre><code>### DbmIdGenerator
比如使用了dbm集成的snowflake策略，下面的配置使用了默认配置的snowflake，如果需要配置不同的datacenter和machine，建议自己实现CustomIdGenerator接口。
</code></pre>
<p>Java<br />
<a href="https://github.com/Entity">@Entity</a><br />
<a href="https://github.com/Table">@Table</a>(name="t_user")<br />
public class UserEntity implements Serializable {</p>
<pre><code>@Id  
@GeneratedValue(strategy = GenerationType.AUTO, generator="snowflake") 
@DbmIdGenerator(name="snowflake", generatorClass=SnowflakeGenerator.class)
protected Long id;
</code></pre>
<p>}</p>
<pre><code>## 复合主键映射
jpa支持三种复合主键映射策略，dbm目前只支持一种： @IdClass 映射。
映射方法如下：
假设有一个表有两个主键：id1，id2。
实体的Java代码如下：
</code></pre>
<p>Java<br />
<a href="https://github.com/Data">@Data</a><br />
<a href="https://github.com/Entity">@Entity</a><br />
<a href="https://github.com/Table">@Table</a>(name="composite_table")<br />
<a href="https://github.com/IdClass">@IdClass</a>(CompositeId.class)<br />
public class CompositeEntity {</p>
<pre><code>@Id  
Long id1;
@Id
Long id2;

@Transient
CompositeId id;

public CompositeId getId() {
    return new CompositeId(id1, id2);
}

public void setId(CompositeId id) {
    this.id1 = id.getId1();
    this.id2= id.getId2();
}

//....其它属性

@Data
public static class CompositeId implements Serializable {
    Long id1;
    Long id2;
}
</code></pre>
<p>}</p>
<pre><code>解释：
- 把需要映射为主键的实体属性都用 @Id 注解标注   
- 另外创建一个复合主键的Pojo类CompositeId，属性为实体需要映射为主键的属性，名称类型一一对应，并实现 java.io.Serializable 接口   
- 在实体类里用 @IdClass 注解标注为复合主键类为 CompositedId 类   
- 实体的CompositeId属性不是必须的，只是为了更方便使用组合id，而且无需持久化，所以如果写的话，需要用 @Transient 注解标注


复合主键实体的查找方法为：
</code></pre>
<p>Java<br />
CompositedId cid = new CompositedId(1, 1);<br />
CompositeEntity entity = baseEntityManager.load(CompositeEntity.class, cid);</p>
<p>int deleteCount = baseEntityManager.removeById(CompositeEntity.class, entity.getId());</p>
<pre><code>## 枚举处理

### 枚举映射
dbm支持jpa的@Enumerated枚举映射注解，使用方法和jpa一样，默认为EnumType.ORDINAL int值类型映射，可以通过注解属性指定为EnumType.STRING名称映射。

但是，当枚举为EnumType.ORDINAL映射的时候，ordinal的值是从0开始根据定义时的先后顺序决定，这使得我们开发的时候很不方便，比如我有一个枚举类型，是需要映射为int类型，但是值并不是从0开始的，这时候就相当的尴尬，因为你既不能用默认为EnumType.ORDINAL,也不能用EnumType.STRING。

所以dbm还另外增加了自定义的int值映射接口DbmEnumValueMapping，只要枚举类型实现了这个接口，就可以自定义返回实际的映射值，比如：
</code></pre>
<p>Java<br />
<a href="https://github.com/Entity">@Entity</a><br />
<a href="https://github.com/Table">@Table</a>(name="TEST_USER")<br />
public class UserEntity {<br />
    <a href="https://github.com/Id">@Id</a><br />
    Long id;<br />
    <a href="https://github.com/Enumerated">@Enumerated</a>(EnumType.ORDINAL)<br />
    UserGenders gender;</p>
<pre><code>public static enum UserGenders {
    FEMALE("女性"),
    MALE("男性");

    final private String label;
    private UserGenders(String label) {
        this.label = label;
    }
    public String getLabel() {
        return label;
    }
}
</code></pre>
<p>}</p>
<pre><code>如果按照jpa的做法，枚举类型映射为@Enumerated(EnumType.ORDINAL)后，用户实体的gender属性对应的数据库列只能是0（FEMALE）和1（MALE）。
在dbm里，你可以通过实现DbmEnumValueMapping接口，返回自定义的映射值，比如10（FEMALE）和11（MALE）。
</code></pre>
<p>Java<br />
<a href="https://github.com/Entity">@Entity</a><br />
<a href="https://github.com/Table">@Table</a>(name="TEST_USER")<br />
public class UserEntity {<br />
    <a href="https://github.com/Id">@Id</a><br />
    Long id;<br />
    <a href="https://github.com/Enumerated">@Enumerated</a>(EnumType.ORDINAL)<br />
    UserGenders gender;</p>
<pre><code>public static enum UserGenders implements DbmEnumValueMapping {
    FEMALE("女性", 10),
    MALE("男性", 11);

    final private String label;
    final private int value;
    private UserGenders(String label, int value) {
        this.label = label;
        this.value = value;
    }
    public String getLabel() {
        return label;
    }
    @Override
    public int getMappingValue() {
        return value;
    }

}
</code></pre>
<p>}</p>
<pre><code>### 枚举属性查询时的处理

- 如果枚举实现了 DbmEnumValueMapping 接口，则取DbmEnumValueMapping#getMappingValue()方法所得的值
- 通过Querys 和 BaseEntityManager 的api查询时，一般直接取枚举的name()方法所得的值
- 如果是@DbmRepository 接口，并且用@Param注解指定了enumType属性，则根据配置的取相应的值，但是DbmEnumValueMapping接口优先级更高



## json映射

有时候，我们需要在数据库的某个字段里存储json格式的数据，又想在获取到数据后转为java对象使用，这时你可以使用 @DbmJsonField 注解，这个注解会在保存实体的时候把对象转化为json字符串，然后在取出数据的时候自动把字符串转化为对象。
示例：
</code></pre>
<p>Java<br />
class SimpleEntity {<br />
    <a href="https://github.com/DbmJsonField">@DbmJsonField</a><br />
    private ExtInfo extInfo;</p>
<pre><code>public static class ExtInfo {
    String address;
    List&lt;String&gt; phones;
}
</code></pre>
<p>}</p>
<pre><code>如果该字段是泛型，需要保存类型信息，可以设置storeTyping属性为true
</code></pre>
<p>Java<br />
class SimpleEntity {<br />
    <a href="https://github.com/DbmJsonField">@DbmJsonField</a>(storeTyping=true)<br />
    private Map<String, ConfigData> configData;</p>
<pre><code>public static class ExtInfo {
    String address;
    List&lt;String&gt; phones;
}
</code></pre>
<p>}</p>
<pre><code>需要添加依赖：
</code></pre>
<p>xml<br />
    <dependency>
      <groupId>org.onetwo4j</groupId>
      <artifactId>onetwo-jackson</artifactId>
    </dependency></p>
<pre><code>## 敏感字段映射

### 加解密映射
对于一些不适宜明文存储的字段信息，比如api密钥，存储的时候自动加密，获取的时候自动解密，此时可以使用@DbmEncryptField 注解。
</code></pre>
<p>Java<br />
<a href="https://github.com/Entity">@Entity</a><br />
<a href="https://github.com/Table">@Table</a>(name="TEST_MERCHANT")<br />
public class MerchantEntity implements Serializable {</p>
<pre><code>@Id
@GeneratedValue(strategy=GenerationType.IDENTITY) 
@Column(name="ID")
protected Long id;

@DbmEncryptField
protected String apikey;
</code></pre>
<p>}</p>
<pre><code>在@DbmRepository 使用这个功能时，可以在插入的参数后面加上后缀函数：
</code></pre>
<p>sql<br />
/<strong>*</strong></p>
<ul>
<li><a href="https://github.com/name">@name</a>: batchInsert</li>
<li>批量插入     */<br />
insert <br />
into<br />
    test_merchant<br />
    (id, apikey) <br />
values<br />
    (:id, :apikey?encrypt)</li>
</ul>
<pre><code>**注意**

- dbm的敏感字段加密功能依赖jasypt

- 你可以通过下面属性配置jasypt的StandardPBEStringEncryptor 
</code></pre>
<p>yaml<br />
  dbm: <br />
      encrypt: <br />
          algorithm: PBEWithMD5AndTripleDES #默认加密算法<br />
          password: test #密钥</p>
<pre><code>### 脱敏映射
对于另一些字段，我们可能并不需要加解密，而只是在存储或者获取的时候，按照一定的规则脱敏。比如手机号码取出的时候自动对后面四位打上星号，或者邮件地址只显示第一个字符和@后面的字符，则可以使用 @DbmSensitiveField 注解进行脱敏映射。
</code></pre>
<p>Java<br />
<a href="https://github.com/Entity">@Entity</a><br />
<a href="https://github.com/Table">@Table</a>(name="TEST_USER")<br />
public class UserEntity implements Serializable {</p>
<pre><code>@Id
@GeneratedValue(strategy=GenerationType.IDENTITY) 
@Column(name="ID")
private Long id;

private String mobile;

    @DbmBindValueToField(name="mobile") //查询实体时，此字段的值来自mobile字段
    @Transient //此字段无需保存到数据库
@DbmSensitiveField(leftPlainTextSize=7, on=SensitiveOns.SELECT)
// 保留手机号码只显示左边7位，如13612345678，取出脱敏后mobile的值为：1361234****
private String mobileUnsensitive;

@DbmSensitiveField(leftPlainTextSize=1, sensitiveIndexOf="@",  on=SensitiveOns.SELECT)
// 邮件地址左边保留一个长度的字符，@后面的字符都保留，其余用星号代替，如test@gmail.com，取出脱敏后为：t***@gmail.com
private String email;
</code></pre>
<p>}</p>
<pre><code>**解释**

DbmSensitiveField 属性解释如下：
- on: 表示进行脱敏的时机，有两个选择：STORE（保存到数据库的时候），SELECT（从数据库获取出来转换为java对象的时候）
- leftPlainTextSize: 脱敏时需要左边保持明文的字符长度
- rightPlainTextSize: 脱敏时需要右边保持明文的字符长度
- sensitiveIndexOf: 当不想整个字段进行脱敏的时候，此属性表示某个指定的字符索引作为脱敏的结束索引。比如邮件脱敏，@字符后面的保留时，此属性值可以写为"@"
- replacementString: 替换敏感数据的字符串，默认为星号



**注意**

此功能从 4.7.4 版本开始支持




### 字段绑定
@DbmBindValueToField 注解可以帮某个字段的值绑定到另一个字段，绑定后，实体查询时，此字段的值将会取自绑定的值。例子可以参考 [脱敏映射](#脱敏映射) 

**注意**

此功能从 4.7.4 版本开始支持




## 其它特有的映射



### @DbmField注解
@DbmField 注解可自定义一个值转换器，用于从数据库表获取的字段值转换为Java对象的属性值，和把Java对象的属性值转换为数据库表的字段值。   
@DbmJsonField 注解实际上是包装了@DbmField注解实现的。




## BaseEntityManager接口和QueryDSL
大多数数据库操作都可以通过BaseEntityManager接口来完成。   
BaseEntityManager可直接注入。   

先来个简单的使用例子：
</code></pre>
<p>java    </p>
<pre><code>@Resource
private BaseEntityManager entityManager;

@Test
public void testSample(){
    UserAutoidEntity user = new UserAutoidEntity();
    user.setUserName("dbm");
    user.setMobile("1333333333");
    user.setEmail("test@test.com");
    user.setStatus(UserStatus.NORMAL);

    //save
    Long userId = entityManager.save(user).getId();
    assertThat(userId, notNullValue());

    //update
    String newMobile = "13555555555";
    user.setMobile(newMobile);
    entityManager.update(user);

    //fetch by id
    user = entityManager.findById(UserEntity.class, userId); 
    assertThat(user.getMobile(), is(newMobile));

    //通过实体属性查找，下面的调用相当于sql条件： where mobile='13555555555' and status IN ('NORMAL', 'DELETE') and age&gt;18
    user = entityManager.findOne(UserAutoidEntity.class, 
                                    "mobile", newMobile,
                                    "status:in", Arrays.asList(UserStatus.NORMAL, UserStatus.DELETE),
                                    "age:&gt;", 18);
    assertThat(user.getId(), is(userId));

    //下面的调用相当于sql条件： where registerTime&gt;=:date1 and registerTime&lt;:date2
    entityManager.findList(UserEntity.class, "registerTime:date in", new Object[]{date1, date2})


}
</code></pre>
<pre><code>BaseEntityManager对象的find开头的接口，可变参数一般都是按键值对传入，相当于一个Map，键是实体对应的属性(+冒号+操作符，可选，不加默认就是=)，值是对应属性的条件值：   
</code></pre>
<p>Java<br />
entityManager.findOne(entityClass, propertyName1, value1, propertyName2, value2……);   <br />
entityManager.findList(entityClass, propertyName1, value1, propertyName2, value2……);</p>
<pre><code>key，value形式的参数最终会被and操作符连接起来。

其中属性名和值都可以传入数组或者List类型的参数，这些多值参数最终会被or操作符连接起来，比如：
- 属性名参数传入一个数组： 
</code></pre>
<p>Java   <br />
entityManager.findList(entityClass, new String[]{propertyName1, propertyName2}, value1, propertyName3, value3);</p>
<pre><code>最终生成的sql语句大概是：
</code></pre>
<p>sql<br />
select t.* from table t where (t.property<em>name1=:value1 or t.property</em>name2=:value1) and t.property_name3=:value3</p>
<pre><code>- 属性值参数传入一个数组： 
</code></pre>
<p>Java   <br />
entityManager.findList(entityClass, propertyName1, new Object[]{value1, value2}, propertyName3, value3);</p>
<pre><code>最终生成的sql语句大概是：
</code></pre>
<p>sql<br />
select t.* from table t where (t.property<em>name1=:value1 or t.property</em>name1=:value2) and t.property_name3=:value3</p>
<pre><code>- find 风格的api会对一些特殊参数做特殊的处理，比如 K.IF_NULL 属性是告诉dbm当查询值查找的属性对应的值为null或者空时，该如何处理，IfNull.Ignore表示忽略这个条件。 **
比如：
</code></pre>
<p>Java   <br />
entityManager.findList(entityClass, propertyName1, new Object[]{value1, value2}, propertyName3, value3, K.IF_NULL, IfNull.Ignore);</p>
<pre><code>那么，当value3（或者任何一个属性对应的值）为nul时，最终生成的sql语句大概是：
</code></pre>
<p>sql<br />
select t.* from table t where (t.property<em>name1=:value1 or t.property</em>name1=:value2) </p>
<pre><code>property_name3条件被忽略了。

### 操作符
BaseEntityManager的属性查询支持如下操作符：   
=, &gt;, &lt;, !=, in, not in, date in, is null, like, not like

### Query DSL API
dbm还提供了一个专门用于构建查询的dsl api
</code></pre>
<p>Java</p>
<p>//使用 querys dsl api<br />
UserAutoidEntity queryUser = Querys.from(entityManager, UserAutoidEntity.class)<br />
                                    .where()<br />
                                        .field("mobile").is(newMobile)<br />
                                        .field("status").is(UserStatus.NORMAL)<br />
                                    .end()<br />
                                    .toQuery()<br />
                                    .one();<br />
assertThat(queryUser, is(user));</p>
<pre><code>注意：
4.7.3后，query dsl api 已集成到 BaseEntityManager 接口，可以通过 BaseEntityManager 直接创建查询：
</code></pre>
<p>Java<br />
public Optional<User> findBy(String month, Long userId) {<br />
        return baseEntityManager.from(User.class)<br />
                                .where()<br />
                                    .field("month").is(month)<br />
                                    .field("userId").is(userId)<br />
                                .toQuery()<br />
                                .optionalOne();<br />
    }</p>
<pre><code>通过链式api和Java8 的 Stream api，你可以创建出这样的查询代码：
</code></pre>
<p>Java<br />
public List<User> findList(String month, Long userId) {<br />
    return baseEntityManager.from(DuesDetailEntity.class)<br />
                        .where()<br />
                            .field("duesMonth").is(month)<br />
                            .field("userId").is(userId)<br />
                        .toQuery()<br />
                        .list()<br />
                        .stream()<br />
                        .map(user -&gt; user.asBean(UserVO.class)) //把实体转换为VO<br />
                        .collect(Collectors.toList());<br />
}</p>
<pre><code>动态条件和or 查询：
</code></pre>
<p>Java<br />
// 下面代码生成的sql条件：(age = 12 and userName like %test%) or (email like %qq.com and mobile=136666666) <br />
public Optional<User> findBy(String month, Long userId) {<br />
        return baseEntityManager.from(User.class)<br />
                .where()<br />
                                .field("age").is(12)<br />
                                .field("userName").when(()-&gt;userName!=null).like(userName) // userName不为null的时候，userName条件才会被生成<br />
                                .or()<br />
                                    .field("email").prelike("qq.com")<br />
                                    .field("mobile").is("13666666666")<br />
                .toQuery()<br />
                .optionalOne();<br />
    }</p>
<pre><code>## CrudEntityManager接口
CrudEntityManager是在BaseEntityManager基础上封装crud的接口，是给喜欢简单快捷的人使用的。   
CrudEntityManager实例可在数据源已配置的情况下通过简单的方法获取：
</code></pre>
<p>java   <br />
<a href="https://github.com/Entity">@Entity</a>   <br />
<a href="https://github.com/Table">@Table</a>(name="TEST<em>USER</em>AUTOID")   <br />
public class UserAutoidEntity {</p>
<pre><code>final static public CrudEntityManager&lt;UserAutoidEntity, Long&gt; crudManager = Dbms.obtainCrudManager(UserAutoidEntity.class);

@Id
@GeneratedValue(strategy=GenerationType.IDENTITY) 
@Column(name="ID")
protected Long id;
@Length(min=1, max=50)
protected String userName;

//省略getter和setter
</code></pre>
<p>}   </p>
<pre><code>然后通过静态变量直接访问crud接口：   
</code></pre>
<p>Java    </p>
<pre><code>UserAutoidEntity.crudManager.save(entity);
UserAutoidEntity user = UserAutoidEntity.crudManager.findOne("userName", userName);
</code></pre>
<pre><code>## DbmRepository动态sql查询接口
DbmRepository接口支持类似mybatis的sql语句与接口绑定，但sql文件不是写在丑陋的xml里，而是直接写在sql文件里，这样用eclipse或者相关支持sql的编辑器打开时，就可以语法高亮，更容易阅读。

### 1、定义一个接口   
包名：test.dao   
</code></pre>
<p>java   <br />
<a href="https://github.com/DbmRepository">@DbmRepository</a><br />
public interface UserAutoidDao {</p>
<pre><code>@ExecuteUpdate
public int removeByUserName(String userName);
</code></pre>
<p>}</p>
<pre><code>### 2、定义一个.jfish.sql文件
在resource源码代码文件下新建一个目录：sql
然后在sql目录里新建一个UserAutoidDao全类名的.jfish.sql文件，完整路径和文件为：
sql/test.dao.UserAutoidDao.jfish.sql
文件内容为：    
</code></pre>
<p>sql<br />
/<strong>*</strong></p>
<ul>
<li><a href="https://github.com/name">@name</a>: removeByUserName</li>
<li>批量删除<br />
*/<br />
delete from test<em>user</em>autoid <br />
    where 1=1 <br />
    ---这里的userName变量就是接口里的userName参数<br />
    [#if userName?has<em>content]
        ---这里的userName命名查询参数也是接口里的userName参数
     and user</em>name like :userName<br />
    [/#if]</li>
</ul>
<pre><code>解释：   
- dbm会根据sql文件名去掉.jfish.sql后缀后作为类名，绑定对应的接口类，此处为：test.dao.UserAutoidDao    
- @name: 表示此sql绑定的方法，此处表示会绑定到UserAutoidDao.removeByUserName方法    
- \[\#if\]...\[/\#if\]，是freemarker的语法，表示条件判断。此处表示，如果userName的值不为空，才生成“user_name like ？” 这个条件   
- :userName，spring jdbc的命名参数，和接口的方法参数绑定 
- @ExecuteUpdate注解表示这个方法会以jdbc的executeUpdate方法执行，实际上可以忽略，因为dbm会识别update，insert，delete等前缀的方法名来判断。

### 3、调用   
</code></pre>
<p>java</p>
<p><a href="https://github.com/Service">@Service</a>   <br />
<a href="https://github.com/Transactional">@Transactional</a>   <br />
public class UserAutoidServiceImpl {</p>
<pre><code>@Resource
private UserAutoidDao userAutoidDao;

public int removeByUserName(){
    return this.userAutoidDao.removeByUserName("%userName%");
}
</code></pre>
<p>}</p>
<pre><code>`
   提示：如果你不想传入 "%userName%"，可以把sql文件里的命名参数“:userName”改成“:userName?likeString”试试，后面的?likeString是调用dbm内置的likeString方法，该方法会自动在传入的参数前后加上'%'。
`
`
   注意：从4.7.3开始，dbm的 DbmRepository接口 支持Java8接口默认方法。
`
### 通过@Query直接在代码里写sql
虽然本人不喜欢不推荐在代码里写sql，但实际开发中经常遇到很多人都是喜欢简单粗暴，直接在代码里通过注解写sql，所以，新版（4.5.2-SNAPSHOT+）的dbm提供了@Query来支持在代码里写sql。

使用示例：
</code></pre>
<p>Java<br />
<a href="https://github.com/DbmRepository">@DbmRepository</a> //标记这是一个dbm的Repository接口<br />
public interface UserDao {</p>
<pre><code>@Query("insert into test_user (id, email, gender, mobile, nick_name, password, status, user_name) "
        + " values (:id, :email, :gender, :mobile, :nickName, :password, :status, :userName)")
int batchSaveUsers(List&lt;UserEntity&gt; users);

@Query(value="select t.* from test_user t where 1=1 "
        + "[#if userName?has_content] "
            + "and t.user_name like :userName?likeString "
        + "[/#if]")
Page&lt;UserEntity&gt; findUserPage(Page&lt;UserEntity&gt; page, String userName);
</code></pre>
<p>}</p>
<pre><code>## 动态sql查询的语法和指令

### 常用指令
sql模板使用的实际上是freemarker模板引擎，因此freemarker支持的语法都可以使用。
一般比较常用到的指令如下：
- if 指令
</code></pre>
<p>sql<br />
[#if 条件表达式]<br />
……<br />
[/#if]</p>
<pre><code>- list 迭代指令
</code></pre>
<p>sql<br />
[#list 可迭代的变量 as item]<br />
……t.column_name = ${item.property1}<br />
[/#list]</p>
<pre><code>条件表达式除了通常的逻辑判断外，还有一些比较常用到的表达式：
- 变量??,双问号，用于判断一个变量是否存在
- 变量?has_content，用于判断变量是有内容，比如字符串的话，相等于判断是否为空。

### dbm扩展指令
另外增加了一些特定的指令以帮助处理sql，包括：

- @foreach
- @str
- @where
- @set
- @dateRange

#### foreach指令
foreach 遍历指令

可以在sql，循环可遍历的参数，并用joiner连接起来，比如当传入ids是个列表，我们需要在sql进入in查询时：
</code></pre>
<p>sql<br />
/***</p>
<ul>
<li><a href="https://github.com/name">@name</a>: findPermissions</li>
<li><a href="https://github.com/parser">@parser</a>: template</li>
<li><br />
<em>/
select 
  t.</em><br />
from <br />
    data t<br />
[#if ids??]<br />
where<br />
    t.id in (<br />
        [@foreach list=ids joiner=', '; id, index]<br />
            #{id}<br />
        [/@foreach]<br />
    )<br />
[/#if]</li>
</ul>
<pre><code>- list 属性：可遍历的参数
- joiner 属性：连接字符
- id：遍历的时候，引用每个正在遍历的元素的变量名
- index：当前遍历的索引
当然，这里只是为了演示foreach指令的用法，实际上，dbm的sql参数可以直接支持list参数类型，当传入的参数是个列表的时候，会自动分解参数。
上面的语句实际上可直接写成： 
</code></pre>
<p>sql<br />
select <br />
      t.*<br />
    from <br />
        data t<br />
   [#if ids??]<br />
    where<br />
        t.id in ( :ids )<br />
   [/#if]</p>
<pre><code>#### str指令
@str 字符串指令

可以在sql动态生成条件查询时，自动插入指定字符，同时去掉头尾多余的字符，比如动态插入where和去掉多余的and或者or：
</code></pre>
<p>sql<br />
/****</p>
<ul>
<li><a href="https://github.com/name">@name</a>: findUsers<br />
*/<br />
select<br />
    *<br />
from<br />
    TEST<em>USER u
[@str insertPrefix='where' trimPrefixs='and | or' trimSuffixs='and | or']
    [#if query.userName?has</em>content]<br />
        u.user_name = :query.userName<br />
    [/#if]<br />
    [#if query.age??]<br />
        and u.age = :query.age<br />
    [/#if]<br />
    [#if query.status??]<br />
        and u.status = :query.status or <br />
    [/#if]<br />
[/@str]</li>
</ul>
<pre><code>- insertPrefix 属性：当指令里面的sql条件不为空的时候，会自动把insertPrefix属性的字符串插入，这里就是where

- trimPrefixs 属性：如果生成的sql片段以trimPrefixs指定的单词开始时，则会自动被去掉。支持指定多个单词，|为分隔符。

- trimSuffixs 属性：如果生成的sql片段以trimSuffixs指定的单词结束时，则会自动被去掉。支持指定多个单词，|为分隔符。


### where指令
where指令可以在sql动态生成条件查询时，自动加上where，或者去掉多余的and或者or关键字，它是@str指令的包装。
@str指令一节里的sql可以用where指令写成这样：
</code></pre>
<p>sql<br />
/****</p>
<ul>
<li><a href="https://github.com/name">@name</a>: findUsersWithWhere<br />
*/<br />
select<br />
    *<br />
from<br />
    TEST<em>USER u
[@where]
    [#if query.userName?has</em>content]<br />
        u.user_name = :query.userName<br />
    [/#if]<br />
    [#if query.age??]<br />
        and u.age = :query.age<br />
    [/#if]<br />
    [#if query.status??]<br />
        and u.status = :query.status or <br />
    [/#if]<br />
[/@where]</li>
</ul>
<pre><code>### set指令
set  指令与where指令类似，只是@str指令的包装，用于sql更新语句：
</code></pre>
<p>sql<br />
/***</p>
<ul>
<li><a href="https://github.com/name">@name</a>: updateUsersWithSet<br />
*/<br />
update<br />
    TEST<em>USER 
[@set]
    [#if query.userName?has</em>content]<br />
        user_name = :query.userName, <br />
    [/#if]<br />
    [#if query.age??]<br />
        age = :query.age, <br />
    [/#if]<br />
    [#if query.status??]<br />
        status = :query.status,<br />
    [/#if]<br />
[/@set]<br />
where <br />
    id = :query.id</li>
</ul>
<pre><code>### 其他特性


- 支持通过特殊的注解参数进行查询分派：
</code></pre>
<p>Java<br />
<a href="https://github.com/DbmRepository">@DbmRepository</a><br />
public interface UserDao {</p>
<pre><code>public List&lt;UserVO&gt; findUserList(@QueryDispatcher String type);
</code></pre>
<p>}</p>
<pre><code>dbm会根据QueryDispatcher注解标记的特殊参数的值，分派到不同的sql。
如果type==inner时，那么这个查询会被分派到findUserList(inner)；
如果type==outer时，那么这个查询会被分派到findUserList(inner)
sql文件：
</code></pre>
<p>sql<br />
/***</p>
<ul>
<li><a href="https://github.com/name">@name</a>: findUserList(inner)<br />
<em>/
select 
usr.</em><br />
from <br />
inner_user usr</li>
</ul>
<p>/***</p>
<ul>
<li><a href="https://github.com/name">@name</a>: findUserList(outer)<br />
<em>/
select 
usr.</em><br />
from <br />
outer_user usr</li>
</ul>
<pre><code>- in条件可以传入 Collection 类型的值，会自动解释为多个in参数
DbmRepository接口：   
</code></pre>
<p>Java<br />
<a href="https://github.com/DbmRepository">@DbmRepository</a><br />
public interface UserDao {</p>
<pre><code>public List&lt;UserVO&gt; findUser(List&lt;String&gt; userNames);
</code></pre>
<p>}</p>
<pre><code>sql文件：   
</code></pre>
<p>sql<br />
/***</p>
<ul>
<li><a href="https://github.com/name">@name</a>: findUser<br />
<em>/
select 
usr.</em><br />
from <br />
t<em>user usr
where 
usr.user</em>name in ( :userNames )</li>
</ul>
<pre><code>注意：必须是Collection类型，不支持数组类型。

- dbm默认会注入一些辅助函数以便在sql文件中调用，可通过_func前缀引用，比如${_func.dateAs(date, "yyyy-MM-dd")}格式化日期。通过QueryConfig注解扩展在sql文件使用的辅助函数集。
sql文件：   
</code></pre>
<p>sql<br />
/***</p>
<ul>
<li><a href="https://github.com/name">@name</a>:</li>
<li>findUser<br />
<em>/
select 
usr.</em><br />
from <br />
t<em>user usr
where 
usr.birthday=${</em>func.dateAs(date, "yyyy-MM-dd")}</li>
</ul>
<pre><code>- 支持Optional类型的返回值



## DbmRepository接口的多数据源支持
DbmRepository 查询接口还可以通过注解支持绑定不同的数据源，dataSource的值为spring bean的名称：
</code></pre>
<p>Java<br />
<a href="https://github.com/DbmRepository">@DbmRepository</a>(dataSource="dataSourceName1")<br />
public interface Datasource1Dao {<br />
}</p>
<p><a href="https://github.com/DbmRepository">@DbmRepository</a>(dataSource="dataSourceName2")<br />
public interface Datasource2Dao {<br />
}</p>
<pre><code>## DbmRepository接口对其它orm框架的兼容
DbmRepository 的查询接口是可以独立于dbm使用的，其它orm框架可以通过实现QueryProvideManager接口，然后通过 @DbmRepository 注解的queryProviderName或queryProviderClass属性指定特定的QueryProvideManager实现类。从而让DbmRepository查询接口使用其它orm框架，避免不同orm框架共存带来的一些副作用。    

dbm内置了JPA（Hibernate）实现的QueryProvideManager。   
但一个一个地把DbmRepository接口设置成相同的实现的QueryProvideManager实现的是不明智，只是没有意义的重复劳动，所以dbm另外提供了@EnableDbmRepository注解，单独激活和配置DbmRepository默认的QueryProvideManager。
</code></pre>
<p>Java<br />
<a href="https://github.com/EnableDbmRepository">@EnableDbmRepository</a>(value="org.onetwo.common.hibernate.dao", <br />
                        defaultQueryProviderClass=HibernateJPAQueryProvideManager.class,<br />
                        autoRegister=true)<br />
    public static class HibernateTestConfig {<br />
}</p>
<pre><code>## 查询映射
DbmRepository的查询映射无需任何xml配置，只需要遵循规则即可：   
- 1、  Java类的属性名与sql查询返回的列名一致(不区分大小写)   
- 2、  或者Java类的属性名采用驼峰命名，而列明采用下划线的方式分隔。如：userName对应user_name   
默认的映射规则实际上和使用了@DbmRowMapper注解下的SMART_PROPERTY模式一致。
详见：[注解@DbmRowMapper](#注解dbmrowmapper)

举例：   
### 创建一个DbmRepository接口
</code></pre>
<p>Java</p>
<p><a href="https://github.com/DbmRepository">@DbmRepository</a><br />
public interface CompanyDao {<br />
    List<CompanyVO> findCompaniesByLikeName(String name);<br />
    List<CompanyVO> findCompaniesByNames(Collection<String> names);<br />
}</p>
<p>public class CompanyVO {<br />
    protected Long id;<br />
    protected String name;<br />
    protected String description;<br />
    protected int employeeNumber;</p>
<pre><code>//省略getter和setter
</code></pre>
<p>}</p>
<pre><code>### 对应的sql文件CompanyDao.jfish.sql
内容如下：   
</code></pre>
<p>sql<br />
/****</p>
<ul>
<li><a href="https://github.com/name">@name</a>: findCompaniesByLikeName<br />
*/<br />
select <br />
comp.id,<br />
comp.name,<br />
comp.description,<br />
comp.employee_number<br />
from<br />
company comp<br />
where<br />
comp.name like :name?likeString</li>
</ul>
<p>/****</p>
<ul>
<li><a href="https://github.com/name">@name</a>: findCompaniesByNames<br />
*/<br />
select <br />
comp.id,<br />
comp.name,<br />
comp.description,<br />
comp.employee_number<br />
from<br />
company comp<br />
[#if names?? &amp;&amp; names?size&gt;0]<br />
where<br />
comp.name in (:names)<br />
[/#if]</li>
</ul>
<pre><code>### 调用代码
</code></pre>
<p>Java<br />
List<CompanyVO> companies = this.companyDao.findCompaniesByLikeName("测试公司");<br />
companies = this.companyDao.findCompaniesByNames(Collections.emptyList());<br />
companies = this.companyDao.findCompaniesByNames(Arrays.asList("测试公司-1", "测试公司-2"));</p>
<pre><code>## 复杂的嵌套查询映射
有时，我们会使用join语句，查询出一个复杂的数据列表，比如包含了company、department和employee三个表。
返回的结果集中，一个company对应多条department数据，而一条department数据又对应多条employee数据，我们希望把多条数据这样的数据最终只映射到一个VO对象里。这时候，你需要使用@DbmResultMapping和@DbmNestedResult两个注解，以指定VO的那些属性需要进行复杂的嵌套映射。

举例如下：
### 创建一个DbmRepository接口和相应的VO
</code></pre>
<p>Java</p>
<p><a href="https://github.com/DbmRepository">@DbmRepository</a><br />
public interface CompanyDao {</p>
<pre><code>@DbmResultMapping({
        @DbmNestedResult(property="departments.employees", columnPrefix="emply_", nestedType=NestedType.COLLECTION),
        @DbmNestedResult(property="departments", id="id", nestedType=NestedType.COLLECTION)
})
List&lt;CompanyVO&gt; findNestedCompanies();
</code></pre>
<p>}</p>
<p>public class CompanyVO {<br />
    protected Long id;<br />
    protected String name;<br />
    protected String description;<br />
    protected int employeeNumber;<br />
    protected List<DepartmentVO> departments;</p>
<pre><code>//省略getter和setter
</code></pre>
<p>}</p>
<p>public class DepartmentVO {<br />
    protected Long id;<br />
    protected String name;<br />
    protected Integer employeeNumber;<br />
    protected Long companyId;<br />
    protected List<EmployeeVO> employees;<br />
    //省略getter和setter<br />
}</p>
<p>public class EmployeeVO  {<br />
    protected Long id;<br />
    protected String name;<br />
    protected Date joinDate;<br />
    //省略getter和setter<br />
}</p>
<pre><code>解释：   
- @DbmResultMapping 注解表明，查询返回的结果需要复杂的嵌套映射
- @DbmNestedResult 注解告诉dbm，返回的CompanyVO对象中，哪些属性是需要复杂的嵌套映射的。property用于指明具体的属性名称，columnPrefix用于指明，需要把返回的结果集中，哪些前缀的列都映射到property指定的属性里，默认会使用property。nestedType标识该属性的嵌套类型，有三个值，ASSOCIATION表示一对一的关联对象，COLLECTION表示一对多的集合对象，MAP也是一对多，但该属性的类型是个Map类型。id属性可选，配置了可一定程度上加快映射速度。

### 对应的sql
</code></pre>
<p>sql<br />
/<strong>*</strong></p>
<ul>
<li><a href="https://github.com/name">@name</a>: findNestedCompanies<br />
<em>/
select 
comp.</em>,<br />
depart.id as departments<em>id,
depart.company</em>id as departments<em>company</em>id,<br />
depart.<code>name</code> as departments<em>name,
emply.name as emply</em>name,<br />
emply.join<em>date as emply</em>join<em>date,
emply.department</em>id as emply<em>department</em>id<br />
from <br />
company comp<br />
left join <br />
department depart on comp.id=depart.company<em>id
left join
employee emply on emply.department</em>id=depart.id</li>
</ul>
<pre><code>### 调用
</code></pre>
<p>Java<br />
List<CompanyVO> companies = companyDao.findNestedCompanies();</p>
<pre><code>- 注意：若嵌套类型为NestedType.COLLECTION，而容器的元素为简单类型，则把@DbmNestedResult 注解的id属性设置为“value”即可。




## 自定义实现DbmRepository接口
dbm的Repository查询接口采用了流行的只有接口没有实现类的风格，但有时你需要的查询，可能不只是写一条sql查询出来即可的，尽管你可以把这种逻辑处理定义到Service，但你又觉得这些是数据处理逻辑并不属于Service，并且你希望把这种实现也挂载到已经存在的Repository查询接口，没问题，dbm支持这种做法。
比如，你已经有了一个名叫UserDao的Repository查询接口，然后你可以自顶一个CustomerUserDao接口：
</code></pre>
<p>Java<br />
public interface CustomUserDao {</p>
<pre><code>int batchInsert(List&lt;UserTableIdEntity&gt; users);
</code></pre>
<p>}</p>
<pre><code>在同一个包路径下，你需要写一个CustomUserDao的实现类，实现类的命名规则是：自定义接口类名+Impl，即：CustomUserDaoImpl：
</code></pre>
<p>Java<br />
<a href="https://github.com/Component">@Component</a><br />
public class CustomUserDaoImpl implements CustomUserDao {<br />
    <a href="https://github.com/Autowired">@Autowired</a><br />
    private BaseEntityManager baseEntityManager;</p>
<pre><code>@Override
public int batchInsert(List&lt;UserTableIdEntity&gt; users) {
    Collection&lt;UserTableIdEntity&gt; dbusers = baseEntityManager.saves(users);
    return dbusers.size();
}
</code></pre>
<p>}</p>
<pre><code>然后再让UserDao继承你的扩展接口：
</code></pre>
<p>Java<br />
<a href="https://github.com/DbmRepository">@DbmRepository</a><br />
public interface UserDao extends CustomUserDao {</p>
<pre><code>List&lt;UserTableIdEntity&gt; findByUserNameLike(String userName);
</code></pre>
<p>}</p>
<pre><code>这样，当你注入UserDao，并调用batchInsert方法时，实际调用的就会是CustomUserDaoImpl的batchInsert方法了：
</code></pre>
<p>Java<br />
public class CustomDaoTest {</p>
<pre><code>@Autowired
private UserDao userDao;

@Test
public void test(){
    int total = 100;
    List&lt;UserTableIdEntity&gt; users = createUsers(total);
    int res = this.userDao.batchInsert(users);
    assertThat(res).isEqualTo(total);
}
</code></pre>
<p>}</p>
<pre><code>## 批量插入

### 使用DbmRepository查询批量插入
在mybatis里，批量插入非常麻烦，我见过有些人甚至使用for循环生成value语句来批量插入的，这种方法插入的数据量如果很大，生成的sql语句以吨计，如果用jdbc接口执行这条语句，系统必挂无疑。   
在dbm里，使用批量接口很简单。   
定义接口：   
</code></pre>
<p>java   </p>
<p>public interface UserAutoidDao {</p>
<pre><code>public int batchInsert(List&lt;UserAutoidEntity&gt; users);
</code></pre>
<p>}</p>
<pre><code>定义sql：     
![batcchInsert](doc/sql.batcchInsert.jpg)



搞掂！   

## 其它映射特性

### 注解@DbmRowMapper
用于配置DbmRepository类的数据映射器，配置指定的mapper，默认为ENTITY模式。
由于标注为实体的映射规则和Pojo默认的映射规则不一致，导致有时候某些查询返回需要用到两种规则时无法兼容，使用此注解的MIXTURE 混合模式可以兼容两种规则。

- ENTITY模式
使用EntryRowMapper映射器。
EntryRowMapper会使用实体的风格映射，即：
如果有@Column注解，则按照注解的映射匹配；
如果没有使用注解，则把属性名称转为下划线匹配；

- SMART_PROPERTY模式：
使用DbmBeanPropertyRowMapper映射属性，即：
自动把bean的属性名称转为小写和下划线两种方式去匹配sql返回的列值。
此模式和不使用@DbmRowMapper注解时一致。

- MIXTURE 混合模式：
先匹配ENTITY模式，如果没有，则匹配SMART_PROPERTY模式


## 充血模型支持   

dbm对充血模型提供一定的api支持，如果觉得好玩，可尝试使用。   
使用充血模型，需要下面几个步骤：
### 1、需要在Configuration类配置model所在的包位置
单独使用dbm的项目，只要model类在@EnableDbm注解所在的配置类的包（包括子包）下面即可，dbm会自动扫描。
</code></pre>
<p>Java</p>
<p><a href="https://github.com/EnableDbm">@EnableDbm</a><br />
public class DbmSampleApplication {<br />
}  </p>
<pre><code>### 2、继承RichModel类
</code></pre>
<p>Java</p>
<p><a href="https://github.com/Entity">@Entity</a><br />
<a href="https://github.com/Table">@Table</a>(name="web_user")<br />
public class User extends RichModel<User, Long> {<br />
}</p>
<pre><code>### 3、使用api
</code></pre>
<p>Java   <br />
//根据id查找实体   <br />
User user = User.findById(id);   <br />
//保存实体   <br />
new User().save();   <br />
//统计<br />
int count = User.count().intValue();   <br />
//查找, K.IF<em>NULL属性是告诉dbm当查询值userName为null或者空时，该如何处理。IfNull.Ignore表示忽略
List<User> users = User.findList("userName", userName, K.IF</em>NULL, IfNull.Ignore);</p>
<pre><code>## 参数配置
- logSql：是否打印执行的sql和时间，默认为true；
需要同时配置日志文件：
</code></pre>
<p>xml<br />
    <!-- print dbm sql--><br />
    <logger name="org.onetwo.dbm.core.internal.LogSqlInterceptor" level="TRACE">
        <appender-ref ref="logFile" />
    </logger></p>
<pre><code>- watchSqlFile：是否监视sql文件，如果有修改则重新加载，默认为true；
- useBatchOptimize：是否使用批量优化save和insert等api的操作，为true并且插入数量超过了设定的阈值，则会把此类api的循环插入优化为jdbc的批量插入，默认为true；
- useBatchThreshold：批量插入的阈值，调用save和insert等api时，如果传入的集合数量超过了阈值，则自动转为批量插入，否则循环插入，默认为50；
- processSizePerBatch：批量插入时，每次提交的数量，默认为10000；
- enableSessionCache：是否启用会话缓存，默认为false；


## 代码生成器
dbm内置了一个代码生成器，可以根据模板生成下列文件：
- 实体
- service
- controller
- 基于freemarker的增删改查页面
- 基于element-ui(vue)的增删改查页面

使用示例：
</code></pre>
<p>Java<br />
DbmGenerator.createWithDburl("jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8", "root", "root")<br />
                    .javaBasePackage("com.test.order")//基础包名<br />
                    .pluginProjectDir("OrderPlugin")//插件项目名称<br />
                    .webadminGenerator("t_order")//要生成的表名<br />
                        .generateEntity()<br />
                        .generateServiceImpl()//配置在service.impl包下生成service类<br />
                        .generateController(BaseController.class)//配置在controller包下生成controller，并制定controller基类<br />
                        .generatePage()//生成freemarker的增删改查页面，配置在src/main/resources/META-INF/resources/webftls/${pluginName}下生成crud页面<br />
                        .generateVueCrud()//生成基于element-ui(vue)的增删改查页面，<br />
                    .end()<br />
                    .build()<br />
                    .generate();//生成文件<br />
```</p>
<h2 id="待续。。。">待续。。。</h2>
<hr/>
<a href="http://www.beian.miit.gov.cn">粤ICP备19161556号</a>

        <style type='text/css'>body {
  font: 400 16px/1.5 "Helvetica Neue", Helvetica, Arial, sans-serif;
  color: #111;
  background-color: #fdfdfd;
  -webkit-text-size-adjust: 100%;
  -webkit-font-feature-settings: "kern" 1;
  -moz-font-feature-settings: "kern" 1;
  -o-font-feature-settings: "kern" 1;
  font-feature-settings: "kern" 1;
  font-kerning: normal;
  padding: 30px;
}

@media only screen and (max-width: 600px) {
  body {
    padding: 5px;
  }

  body > #content {
    padding: 0px 20px 20px 20px !important;
  }
}

body > #content {
  margin: 0px;
  max-width: 900px;
  border: 1px solid #e1e4e8;
  padding: 10px 40px;
  padding-bottom: 20px;
  border-radius: 2px;
  margin-left: auto;
  margin-right: auto;
}

hr {
  color: #bbb;
  background-color: #bbb;
  height: 1px;
  flex: 0 1 auto;
  margin: 1em 0;
  padding: 0;
  border: none;
}

/**
 * Links
 */
a {
  color: #0366d6;
  text-decoration: none; }
  a:visited {
    color: #0366d6; }
  a:hover {
    color: #0366d6;
    text-decoration: underline; }

pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

/**
  * Code blocks
  */

code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  word-wrap: break-word;
  padding: .2em .4em;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
}

pre > code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
  font-size: 100%;
}


/**
 * Blockquotes
 */
blockquote {
  margin-left: 30px;
  margin-top: 0px;
  margin-bottom: 16px;
  border-left-width: 3px;
  padding: 0 1em;
  color: #828282;
  border-left: 4px solid #e8e8e8;
  padding-left: 15px;
  font-size: 18px;
  letter-spacing: -1px;
  font-style: italic;
}
blockquote * {
  font-style: normal !important;
  letter-spacing: 0;
  color: #6a737d !important;
}

/**
 * Tables
 */
table {
  border-spacing: 2px;
  display: block;
  font-size: 14px;
  overflow: auto;
  width: 100%;
  margin-bottom: 16px;
  border-spacing: 0;
  border-collapse: collapse;
}

td {
  padding: 6px 13px;
  border: 1px solid #dfe2e5;
}

th {
  font-weight: 600;
  padding: 6px 13px;
  border: 1px solid #dfe2e5;
}

tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

/**
 * Others
 */

img {
  max-width: 100%;
}

p {
  line-height: 24px;
  font-weight: 400;
  font-size: 16px;
  color: #24292e; }

ul {
  margin-top: 0; }

li {
  color: #24292e;
  font-size: 16px;
  font-weight: 400;
  line-height: 1.5; }

li + li {
  margin-top: 0.25em; }

* {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  color: #24292e; }

a:visited {
  color: #0366d6; }

h1, h2, h3 {
  border-bottom: 1px solid #eaecef;
  color: #111;
  /* Darker */ }</style>
      </body>
    </html>
